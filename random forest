import ccxt
import pandas as pd

try:
    exchange = ccxt.binance()
    symbol = 'BTC/USDT'
    timeframe = '1h'
    limit = 1000

    ohlcv = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df = df[['timestamp', 'open', 'high', 'low', 'close', 'volume']]
    df.to_csv('bitcoin_1h.csv', index=False)
    print("âœ… CSV ì €ì¥ ì™„ë£Œ")

except Exception as e:
    print("âŒ ì—ëŸ¬ ë°œìƒ:", e)
!pip install ta
"""
ğŸ“Œ ê¸°ìˆ ì  ì§€í‘œ ì»¬ëŸ¼ ë‹¨ìœ„ ê¸°ì¤€ ì •ë¦¬

- returns (%)         : ìˆ˜ìµë¥ , ì „ ì‹œê°„ ëŒ€ë¹„ ë³€í™”ìœ¨ (%)
- sma_20 (USD)        : 20ì‹œê°„ ë‹¨ìˆœ ì´ë™ í‰ê·  (ë‹¬ëŸ¬)
- ema_20 (USD)        : 20ì‹œê°„ ì§€ìˆ˜ ì´ë™ í‰ê·  (ë‹¬ëŸ¬)
- volatility_20 (Ïƒ%)  : 20ì‹œê°„ ìˆ˜ìµë¥ ì˜ í‘œì¤€í¸ì°¨ (%, Ïƒ ë‹¨ìœ„)
- rsi (0~100)         : ìƒëŒ€ê°•ë„ì§€ìˆ˜ (Relative Strength Index)
- bb_bbm (USD)        : ë³¼ë¦°ì € ë°´ë“œ ì¤‘ì•™ì„  (20ê¸°ê°„ í‰ê· , ë‹¬ëŸ¬)
- bb_bbh (USD)        : ë³¼ë¦°ì € ë°´ë“œ ìƒë‹¨ (20ê¸°ê°„ í‰ê·  + 2Ïƒ)
- bb_bbl (USD)        : ë³¼ë¦°ì € ë°´ë“œ í•˜ë‹¨ (20ê¸°ê°„ í‰ê·  - 2Ïƒ)
"""

import pandas as pd
import ta

# ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° ë° ì‹œê°„ ì¸ë±ìŠ¤ ì„¤ì •
df = pd.read_csv('bitcoin_1h.csv', parse_dates=['timestamp'])
df = df.set_index('timestamp')

# ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚° + ì»¬ëŸ¼ëª…ì— ë‹¨ìœ„ ì¶”ê°€
df['returns (%)'] = df['close'].pct_change() * 100  # í¼ì„¼íŠ¸ë¡œ í™˜ì‚°
df['sma_20 (USD)'] = df['close'].rolling(window=20).mean()
df['ema_20 (USD)'] = df['close'].ewm(span=20, adjust=False).mean()
df['volatility_20 (Ïƒ%)'] = df['returns (%)'].rolling(window=20).std()  # í¼ì„¼íŠ¸ ê¸°ì¤€ í‘œì¤€í¸ì°¨
df['rsi (0~100)'] = ta.momentum.RSIIndicator(close=df['close'], window=14).rsi()

# Bollinger Bands (20ê¸°ê°„, Â±2Ïƒ)
bb = ta.volatility.BollingerBands(close=df['close'], window=20, window_dev=2)
df['bb_bbm (USD)'] = bb.bollinger_mavg()
df['bb_bbh (USD)'] = bb.bollinger_hband()
df['bb_bbl (USD)'] = bb.bollinger_lband()

# ê²°ê³¼ í™•ì¸
df.tail()
features = df[['returns (%)', 'sma_20 (USD)', 'volatility_20 (Ïƒ%)', 'rsi (0~100)']]
features = features.dropna()  # ê²°ì¸¡ì¹˜ ì œê±°
from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
scaled_features = scaler.fit_transform(features)
from sklearn.cluster import KMeans

k = 4  # êµ°ì§‘ ê°œìˆ˜: 3~6ê°œê°€ ì¼ë°˜ì . ë°”ê¿”ê°€ë©° í…ŒìŠ¤íŠ¸ ê°€ëŠ¥
kmeans = KMeans(n_clusters=k, random_state=42)
cluster_labels = kmeans.fit_predict(scaled_features)
df.loc[features.index, 'market_state'] = cluster_labels
df['market_state'] = df['market_state'].fillna(-1).astype(int)  # ì—¬ê¸°ë¥¼ ì´ë ‡ê²Œ ìˆ˜ì •

import matplotlib.pyplot as plt

plt.figure(figsize=(15,6))
for cluster in df['market_state'].dropna().unique():
    cluster_data = df[df['market_state'] == cluster]
    plt.scatter(cluster_data.index, cluster_data['close'], label=f'Cluster {cluster}', s=10)

plt.legend()
plt.title("Bitcoin Price by Market Cluster (K-Means)")
plt.ylabel("BTC Price (USD)")
plt.show()

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix
import matplotlib.pyplot as plt

# 1. ìˆ˜ìµë¥  ê³„ì‚° ë° **3ë‹¨ê³„ ë¼ë²¨ ì„¤ì •**
def classify_return(x):
    if x > 0.002:
        return 1   # ìƒìŠ¹
    elif x < -0.003:
        return -1  # í•˜ë½
    else:
        return 0   # íš¡ë³´

df['future_return'] = (df['close'].shift(-1) - df['close']) / df['close']
df['target'] = df['future_return'].apply(classify_return)

# 2. í”¼ì²˜ ì„¤ì • ë° ê²°ì¸¡ì¹˜ ì œê±°
features = ['returns (%)', 'sma_20 (USD)', 'volatility_20 (Ïƒ%)', 'rsi (0~100)', 'market_state']
df_model = df[features + ['target']].dropna()

X = df_model[features]
y = df_model['target']

# 3. í•™ìŠµ/í…ŒìŠ¤íŠ¸ ë¶„í• 
X_train, X_test, y_train, y_test = train_test_split(X, y, shuffle=False, test_size=0.2)

# 4. RandomForest í•™ìŠµ
model = RandomForestClassifier(random_state=42)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

# 5. ì„±ëŠ¥ í‰ê°€
print(classification_report(y_test, y_pred))
print(confusion_matrix(y_test, y_pred))

# 6. í”¼ì²˜ ì¤‘ìš”ë„ ì‹œê°í™”
importances = model.feature_importances_
plt.barh(X.columns, importances)
plt.title("Feature Importance")
plt.show()
df['target'].value_counts(normalize=True)
print(df['target'].value_counts())
print(df['target'].value_counts(normalize=True).round(3))  
pip install scikit-plot

import scikitplot as skplt
import matplotlib.pyplot as plt

skplt.metrics.plot_confusion_matrix(y_test, y_pred, normalize=True)
plt.title("Confusion Matrix (Normalized)")
plt.show()
from sklearn.metrics import classification_report

report = classification_report(y_test, y_pred, output_dict=True)
print("Macro F1-score:", round(report['macro avg']['f1-score'], 3))
from sklearn.ensemble import RandomForestClassifier

model = RandomForestClassifier(class_weight='balanced', random_state=42)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
